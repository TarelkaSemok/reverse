## Статический анализ.
Проведен с помощью **jadx 1.2.0**.
Предполагаемый алгоритм работы приложения:
1) Основная активность: example.com.crackme.MainActivity с полем для кода и кнопкой "проверить"
2) По кнопке вызывается метод example.com.crackme.Checker. Внутри которого уже вызывается example.com.crackme.i.checkKey.

Встреченные методы защиты:
1) Обфускация кода - замена имен переменных на нечитаемый набор символов
2) Обфускация функционала - необходимые классы и методы подгружаются динамически в ходе работы приложения
3) Упаковка данных (?) - названия классов, методов, прочие числовые данные упакованы в единый массив. В ходе работы приложения происходит извлечение необходимых данных.

Деобфусцированный код метода checkKey приведен [здесь](https://github.com/TarelkaSemok/reverse/blob/patch-1/intro/solution/checkKey_method.java)
Реверс алгоритма генерации секретного ключа проводился в Python, скрипт [тут](https://github.com/TarelkaSemok/reverse/blob/patch-1/intro/solution/jupyter_sketch.py). Сам алгоритм:
1) Получить хэш SHA-1 на основе данных из статического массива L. Его первые 16 байт будут ключом для AES дешифровки дальше.
2) Сформировать массив из данных из статического массива L и из захардкоженного массива в самом методе. Этот 32-байтный массив - AES зашифрованный секретный ключ.
3) Расшифровать с помощью AES секретную _строку_ и сравнить с входной _строкой_. 
(Здесь пришлось угадывать метод шифрования. Вроде только AES.MODE_ECB не требует приватного(?) ключа, поэтому выбираем его)
4) После реверса видим, что секретный ключ = "3814606579781593"

## Динамический анализ
По какой-то причине ввод секретного ключа в реальное приложение в эмуляторе и в живом телефоне все равно не срабатывает. (Версия андроида 7.1.0 и 8.1.0 соответственно).
Поэтому я решил поковырять с помощью **Frida**. Скрипт [тут](https://github.com/TarelkaSemok/reverse/blob/patch-1/intro/solution/crackme.js).

Повесив хук на интересующий нас метод checkKey, можно переписать проверку входной строки без шелухи в виде оберток try{}catch{} и прочей обфускации.
Также можно хукнуть метод расшифроки AES, чтобы отследить вход и выход. У нас уже есть ключ и входная строка, поэтому передаем их статично через скрипт. 
Хорошая новость в том, что расшифровка действительно совпадает с результатом стат. анализа. 

Вывод консоли Frida:

![Frida console](https://github.com/TarelkaSemok/reverse/blob/patch-1/intro/solution/frida_con.png)
