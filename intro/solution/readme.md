## Статический анализ.
Проведен с помощью **jadx 1.2.0**.
Предполагаемый алгоритм работы приложения:
1) Основная активность: example.com.crackme.MainActivity с полем для кода и кнопкой "проверить"
2) По кнопке вызывается метод example.com.crackme.Checker. Внутри которого уже вызывается example.com.crackme.i.checkKey.

Встреченные методы защиты от декомпиляции:
1) Обфускация кода - замена имен переменных на нечитаемый набор символов
2) Обфускация функционала - необходимые классы и методы подгружаются динамически в ходе работы приложения
3) Упаковка данных - названия классов, методов, прочие числовые данные упакованы в единый массив. В ходе работы приложения происходит извлечение необходимых данных.

Деобфусцированный код метода checkKey приведен [здесь](https://github.com/TarelkaSemok/reverse/blob/patch-1/intro/solution/checkKey_method.java)
Реверс алгоритма генерации секретного ключа проводился в Python, скрипт [тут](https://github.com/TarelkaSemok/reverse/blob/patch-1/intro/solution/jupyter_sketch.py). Сам алгоритм:
1) Получить хэш SHA-1 на основе данных из статического массива L. Его первые 16 байт будут ключом для AES дешифровки дальше.
2) Сформировать массив из данных из статического массива L и из захардкоженного массива в самом методе. Этот 32-байтный массив - AES зашифрованный секретный ключ.
3) Расшифровать с помощью AES секретную _строку_ и сравнить с входной _строкой_. 
(Здесь пришлось угадывать метод шифрования. Вроде только AES.MODE_ECB не требует приватного(?) ключа, поэтому выбираем его)
4) После реверса видим, что секретный ключ = "3814606579781593"

До момента выполнения кода генерации ключа происходит еще несколько проверок:
1) Классы **java.lang.String**, **android.content.Context**, **android.telephony.TelephonyManager**, **java.lang.System** загружены корректно
2) Методы  **android.content.Context.getResources**, **java.lang.String.length**, **java.lang.String.equals**, **java.lang.System.exit**, **android.telephony.TelephonyManager.getDeviceId** загружены корректно
3) IMEI девайса не должен быть равен "000000000000000" (проверка на эмулятор)
4) Длина входной строки без учета знаков "-" должна быть равна 16


## Динамический анализ
~~По какой-то причине~~ ввод секретного ключа в реальное приложение в эмуляторе и в живом телефоне все равно не срабатывает. (Об этом в следующей части).
Поэтому я решил поковырять с помощью **Frida**. Скрипт [тут](https://github.com/TarelkaSemok/reverse/blob/patch-1/intro/solution/crackme.js).

Повесив хук на интересующий нас метод checkKey, можно переписать проверку входной строки без шелухи в виде оберток try{}catch{} и прочей обфускации.
Также можно хукнуть метод расшифроки AES, чтобы отследить вход и выход. У нас уже есть ключ и входная строка, поэтому передаем их статично через скрипт. 
Хорошая новость в том, что расшифровка действительно совпадает с результатом стат. анализа. 

Вывод консоли Frida:

![Frida console](/intro/solution/frida_con.png)

## Продолжение анализа
Теперь о том, почему в чистом приложении проверка ключа все равно не срабатывает.

Во время динамического анализа я заметил, что хук метода расшифровки "iiiilll" не срабатывает даже при вводе правильного ключа. Это значит, что до него дело просто не доходит и метод checkKey вываливается где-то с исключением. А все исключения, _кроме одного_, обрабатываются с отрицательным результатом KEY_INVALID. Чтобы выяснить причину исключения попробуем изнутри приложения с помощью [Frida](https://github.com/TarelkaSemok/reverse/blob/patch-1/intro/solution/crackme.js) поочередно выполнять проверки из try{}catch{} оберток. 

![Frida console2](/intro/solution/frida_con2.png)

Попался! Вызов **android.telephony.TelephonyManager.getDeviceId()** выпадает с исключением, потому что нет разрешения в [манифесте](https://developer.android.com/reference/android/telephony/TelephonyManager#getDeviceId()). То есть приложение изначально написано так, что проверка невыполнима. 

Давайте заставим приложение работать все-таки. Для этого
* распаковываем apk
* добавляем в Manifest строку "\<uses-permission android:name="android.permission.READ_PHONE_STATE" /\>"
* запаковываем обратно 
* подписываем 
* даем вручную приложению права на доступ к "Телефон"

![Permissions](/intro/solution/permission.png)
* Profit!!!

![success](/intro/solution/success.png)
  

